"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCypressResults = exports.combineResults = exports.parseAndAnalyzeReports = exports.analyzeResults = exports.resultsWithCases = exports.getErrorForTest = void 0;
const fs_1 = __importDefault(require("fs"));
const parseSingleTestResults_1 = require("./parseSingleTestResults");
/**
 * Get Formatted Error for Test. Pass optional title to prefix errors
 * @param test
 * @param testTitle
 */
function getErrorForTest(test, testTitle = null) {
    if (!test.err || !test.err.message)
        return false;
    let { message } = test.err;
    if (testTitle) {
        message = `${testTitle}: ${message}`;
    }
    return Object.assign(Object.assign({}, test.err), { message });
}
exports.getErrorForTest = getErrorForTest;
function resultsWithCases(r) {
    return Object.entries(r.cases || {}).length > 0;
}
exports.resultsWithCases = resultsWithCases;
function analyzeResults(acc, result) {
    acc.passed += Object.keys(result.cases)
        .filter((id) => result.cases[id].results.every((testRailStatusId) => testRailStatusId === 1))
        .length;
    acc.failed += Object.keys(result.cases)
        .filter((id) => result.cases[id].results.some((testRailStatusId) => testRailStatusId === 5))
        .length;
    acc.skipped += Object.keys(result.cases)
        .filter((id) => result.cases[id].results.some((testRailStatusId) => testRailStatusId === 2))
        .length;
    return acc;
}
exports.analyzeResults = analyzeResults;
function parseAndAnalyzeReports(acc, report) {
    const parsedTestResults = [];
    // Read Content from JSON
    const content = fs_1.default.readFileSync(report.trim(), { encoding: 'utf-8' });
    // Parse Content
    const combinedReport = JSON.parse(content);
    // Scan
    combinedReport.results.reduce(parseSingleTestResults_1.parseSingleTestResults, parsedTestResults);
    acc.tests = [
        ...acc.tests,
        ...parsedTestResults,
    ];
    // Quickly analyze results
    acc.analysis = parsedTestResults.reduce(analyzeResults, acc.analysis);
    // Return combined Results
    return acc;
}
exports.parseAndAnalyzeReports = parseAndAnalyzeReports;
function combineResults(acc, result) {
    Object.keys(result.cases).forEach((caseId) => {
        const match = acc.findIndex((r) => r.caseId === caseId);
        if (match < 0) {
            // ADD New Result
            acc.push(result.cases[caseId]);
        }
        else {
            // Extend existing result
            acc[match] = Object.assign(Object.assign({}, (acc[match] ? acc[match] : result.cases[caseId])), { results: [
                    ...acc[match].results,
                    ...result.cases[caseId].results,
                ], err: [
                    ...acc[match].err,
                    ...result.cases[caseId].err,
                ] });
        }
    });
    return acc;
}
exports.combineResults = combineResults;
function parseCypressResults(cypressReportFilenames) {
    return new Promise((resolve) => {
        const results = {
            analysis: {
                passed: 0,
                failed: 0,
                skipped: 0,
            },
            tests: [],
            testRailCases: [],
        };
        if (cypressReportFilenames) {
            const cypressReports = cypressReportFilenames.split(',');
            cypressReports.reduce(parseAndAnalyzeReports, results);
            // prepare cases
            results.tests
                .filter(resultsWithCases)
                .reduce(combineResults, results.testRailCases);
        }
        return resolve(results);
    });
}
exports.parseCypressResults = parseCypressResults;
exports.default = parseCypressResults;
